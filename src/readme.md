# 자료구조
- Queue
	- FIFO (First In First Out) = 선입선출
	- 앞 front - Dequeue(큐의 프론트에서 자료 제거 후 반환) | ... | 뒤 rear - Enqueue(큐의 리어에 새로운 자료 추가)
	- peek : 큐에서 프런트의 자료를 반환, 하지만 제거는 안함.
	
- 그래프 Graph
	- 정점(node)과 그 정점을 연결하는 간선(edge)으로 이루어진 자료구조.
	- 그래프 탐색 = 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것
	- 그래프 종류
		- 이분 그래프 Bipartite Graph
			- 정점을 2그룹으로 나눌 수 있으되 같은 그룹의 정점끼리는 간선으로 이어지지 않은 경우
			- 같은 레벨의 꼭짓점끼리는 무조건 같은 색, 인접한 정점 사이는 다른 색
			- 간선이 아예 없고 정점만 있는 경우도 이분 그래프
			- 사용) 다양한 관계를 나타내는 맵
			- 문제: TestBackJoon.D220919T1707BipartiteGraph.java

# 알고리즘
- DFS
	- Depth-First Search; 깊이 우선 탐색.
	- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 최대한 깊이 내려간(=해당 분기(branch)를 완벽하게 탐색) 뒤 더이상 깊이 갈 곳이 없을 경우 옆(다음 분기)으로 이동.
	- 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색.
	- 스택 또는 재귀함수로 구현.
	- 구현 방식이 BFS 보다 간단.
	- 검색 속도가 BFS 보다 느림.
	- 문제 유형
		- 그래프의 모든 정점을 방문하기.
		- 경로의 특징을 저장하기.
		- 검색 대상 그래프의 규모가 큰 경우.
		- TestBackJoon.D220826T24479DFS1.java
	- 의사코드	
		```
		dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점
		    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.
		    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)
		        if (visited[x] = NO) then dfs(V, E, x);
		}
		```
	- 시간복잡도
		- V: 정점, E: 간선=한 정점의 주변 노드
		- 인접 리스트로 구현 시: O(V+E) <- 효율적
		- 인접 행렬로 구현 시: O(V^2)

- BFS
	- Breadth-First Search; 너비 우선 탐색.
	- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 최대한 넓게 이동(=인접한 노드를 먼저 탐색)한 다음, 더 이상 갈 수 없을 때 아래로 이동.
	- 현재 정점에서 연결된 가까운 점들부터 탐색.
	- 큐로 구현.
	- 문제 유형
		- 그래프의 모든 정점을 방문하기.
		- 두 노드 사이의 최단 경로를 찾기. 단, 가중치가 1인 경우에만 해당!
		- 검색 대상 그래프의 규모가 크지 않고 검색 시작 지점으로부터 원하는 대상이 멀지 않은 경우.
		- TestBackJoon.D220829T24444BFS1.java
	- 시간복잡도 : DFS 동일
	
- 다익스트라(Dijkstra) 알고리즘
	- 모든 간선의 가중치가 양수인 그래프의 한 정점(Vertex)에서 모든 정점까지의 최단거리를 각각 구하는 알고리즘.
	- 최소 비용을 가지는 간선만 우선적으로 뽑으면서 경우의 수를 줄여가며 비용을 갱신.
	- 에츠허르 다익스트라가 고안
	- 문제 유형
		- 최단 경로 문제 Shortest Path Problem
	- 동작 원리 : 탐색하는데 BFS, 가중치를 기록하고 재사용하는데 DP 원리
		1. 시작 정점과 직접적으로 연결된 모든 정점들의 거리를 비교해서 업데이트 시킨 후 시작 정점을 방문한 정점으로 처리.
		2. 방문한 정점들과 연결되어 있는 정점들 중 비용이 가장 적게 드는 정점을 선택한 후 해당 정점을 방문한 정점으로 처리.
		3. 2번 과정에 의해서 갱신될 수 있는 정점들의 거리를 갱신시켜줌.
		4. 2 ~ 3번 과정을 반복.
	- 시간복잡도
		- 최초 O(V^2)
		- 우선순위 큐(=힙 트리) 등을 이용하면 O((V+E)logV) 
			= O(V)*O(logV) (← 각 노드(O(V))마다 미방문 노드 중 출발점으로부터 현재까지 계산된 최단 거리를 가지는 노드(힙에서 최소값을 추출(O(logV))를 찾는 시간)
				+ O(E)*O(logV) (← 각 노드마다 이웃한 노드(O(E))의 최단 거리를 갱신(매번 힙에서 추출(O(logV)) 할 때 시간)
	- 출처 
		https://devuna.tistory.com/32
		https://yabmoons.tistory.com/364
		
- 벨먼-포드(Bellman-Ford) 알고리즘
	- 가중 유향 그래프에서 최단 경로 문제를 푸는 알고리즘.
	- 다이나믹 프로그래밍(DP)이기도 함 → 매번 저장해놓은 최소 비용을 이용해서 새로운 최소 비용으로 갱신.
	- Dijkstra 알고리즘과 다르게 음의 간선 때문에 모든 경우의 수를 탐색해야 함 → 중복 방문 허용
	- 시간복잡도
		- O(VE) (← 모든 정점의 모든 간선을 매번 탐색함)
	- 동작원리
		1. 시작 정점을 선택.
		2. 다음의 과정을 'V(정점의 수)-1'번만큼 반복. (→ 정점 A에서 정점 B가지의 최단 거리는 최대 V-1개의 정점을 지나기 때문)
			2-1. 모든 간선 E개를 모두 탐색
			2-2. 시작 정점에서 다른 정점까지의 거리가 INF가 아니라면 최단 경로 값을 갱신.
		3. 만약 음수 간선 순환이 발생하는지 확인하려면 2번 과정을 한번 더 실행.
			이 때 최단 경로가 갱신 된다면 음의 사이클이 발생한 것(=비용이 무한하게 갱신)이므로 최단 경로를 구할 수 없음.
	- 출처
		https://sorjfkrh5078.tistory.com/30