# 자료구조
## Queue
	- FIFO (First In First Out) = 선입선출
	- 앞 front - Dequeue(큐의 프론트에서 자료 제거 후 반환) | ... | 뒤 rear - Enqueue(큐의 리어에 새로운 자료 추가)
	- peek : 큐에서 프런트의 자료를 반환, 하지만 제거는 안함.
	
## 그래프 Graph
	- 정점(node)과 그 정점을 연결하는 간선(edge)으로 이루어진 자료구조.
	- 그래프 탐색 = 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것
	- 그래프 종류
		- 이분 그래프 Bipartite Graph
			- 정점을 2그룹으로 나눌 수 있으되 같은 그룹의 정점끼리는 간선으로 이어지지 않은 경우
			- 같은 레벨의 꼭짓점끼리는 무조건 같은 색, 인접한 정점 사이는 다른 색
			- 간선이 아예 없고 정점만 있는 경우도 이분 그래프
			- 사용) 다양한 관계를 나타내는 맵
			- 문제: TestBackJoon.D220919T1707BipartiteGraph.java

# 알고리즘
## DFS
	- Depth-First Search; 깊이 우선 탐색.
	- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 최대한 깊이 내려간(=해당 분기(branch)를 완벽하게 탐색) 뒤 더이상 깊이 갈 곳이 없을 경우 옆(다음 분기)으로 이동.
	- 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색.
	- 스택 또는 재귀함수로 구현.
	- 구현 방식이 BFS 보다 간단.
	- 검색 속도가 BFS 보다 느림.
	- 문제 유형
		- 그래프의 모든 정점을 방문하기.
		- 경로의 특징을 저장하기.
		- 검색 대상 그래프의 규모가 큰 경우.
		- TestBackJoon.D220826T24479DFS1.java
	- 의사코드	
		```
		dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점
		    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.
		    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)
		        if (visited[x] = NO) then dfs(V, E, x);
		}
		```
	- 시간복잡도
		- V: 정점, E: 간선=한 정점의 주변 노드
		- 인접 리스트로 구현 시: O(V+E) <- 효율적
		- 인접 행렬로 구현 시: O(V^2)

## BFS
	- Breadth-First Search; 너비 우선 탐색.
	- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 최대한 넓게 이동(=인접한 노드를 먼저 탐색)한 다음, 더 이상 갈 수 없을 때 아래로 이동.
	- 현재 정점에서 연결된 가까운 점들부터 탐색.
	- 큐로 구현.
	- 문제 유형
		- 그래프의 모든 정점을 방문하기.
		- 두 노드 사이의 최단 경로를 찾기. 단, 가중치가 1인 경우에만 해당!
		- 검색 대상 그래프의 규모가 크지 않고 검색 시작 지점으로부터 원하는 대상이 멀지 않은 경우.
		- TestBackJoon.D220829T24444BFS1.java
	- 시간복잡도 : DFS 동일
	
## 다익스트라(Dijkstra) 알고리즘
	- 모든 간선의 가중치가 양수인 그래프의 한 정점(Vertex)에서 모든 정점까지의 최단거리를 각각 구하는 알고리즘.
	- 최소 비용을 가지는 간선만 우선적으로 뽑으면서 경우의 수를 줄여가며 비용을 갱신.
	- 에츠허르 다익스트라가 고안
	- 문제 유형
		- 최단 경로 문제 Shortest Path Problem
	- 동작 원리 : 탐색하는데 BFS, 가중치를 기록하고 재사용하는데 DP 원리
		1. 시작 정점과 직접적으로 연결된 모든 정점들의 거리를 비교해서 업데이트 시킨 후 시작 정점을 방문한 정점으로 처리.
		2. 방문한 정점들과 연결되어 있는 정점들 중 비용이 가장 적게 드는 정점을 선택한 후 해당 정점을 방문한 정점으로 처리.
		3. 2번 과정에 의해서 갱신될 수 있는 정점들의 거리를 갱신시켜줌.
		4. 2 ~ 3번 과정을 반복.
	- 시간복잡도
		- 최초 O(V^2)
		- 우선순위 큐(=힙 트리) 등을 이용하면 O((V+E)logV) 
			= O(V)*O(logV) (← 각 노드(O(V))마다 미방문 노드 중 출발점으로부터 현재까지 계산된 최단 거리를 가지는 노드(힙에서 최소값을 추출(O(logV))를 찾는 시간)
				+ O(E)*O(logV) (← 각 노드마다 이웃한 노드(O(E))의 최단 거리를 갱신(매번 힙에서 추출(O(logV)) 할 때 시간)
	- 출처 
		https://devuna.tistory.com/32
		https://yabmoons.tistory.com/364
		
## 벨먼-포드(Bellman-Ford) 알고리즘
	- 가중 유향 그래프에서 최단 경로 문제를 푸는 알고리즘.
	- 다이나믹 프로그래밍(DP)이기도 함 → 매번 저장해놓은 최소 비용을 이용해서 새로운 최소 비용으로 갱신. 
	- Dijkstra 알고리즘과 다르게 음의 간선 때문에 모든 경우의 수를 탐색해야 함 → 중복 방문 허용
	- 시간복잡도
		- O(VE) (← 모든 정점의 모든 간선을 매번 탐색함)
	- 동작원리
		1. 시작 정점을 선택.
		2. edge relaxation: 다음의 과정을 'V(정점의 수)-1'번만큼 반복. (→ 정점 A에서 정점 B가지의 최단 거리는 최대 V-1개의 정점을 지나기 때문)
			2-1. 모든 간선 E개를 모두 탐색
			2-2. 시작 정점에서 다른 정점까지의 거리가 INF가 아니라면(→ 시작지점으로부터 이어진 정점의 최소 거리를 구하기 위함)
				최단 경로 값을 갱신.
		3. 만약 음수 간선 순환(negative-weight cycle)이 존재하는지 확인하려면 2번 과정을 한번 더 실행.
			이 때 최단 경로가 갱신 된다면 음의 사이클이 발생한 것(=비용이 무한하게 갱신)이므로 최단 경로를 구할 수 없음.
		- edge relaxation: 두 경로 사이에 더 가까운 경로가 있다면 해당 경로의 거리로 간선을 경감하는 작업
	- 주의점
		- 벨만 포드는 가중치가 INF 일 때도 계속 계산을 해야하므로 MAX_VALUE로 넣으면 overflow가 발생하여 오류가 됨.
	- 출처
		https://sorjfkrh5078.tistory.com/30
		https://chb2005.tistory.com/79
		
## 탐욕 알고리즘
#### = Greedy 알고리즘
#### 개요
	- 동적 프로그래밍 사용 시 지나치게 많은 일을 한다는 것에서 착안하여 고안된 알고리즘.
	- → 동적 프로그래밍을 대체하는 것은 아니고 같이 쓰이며 서로 보완하는 개념.
	- 미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 기법.
	- → 각 단계에서 최선의 선택을 한 것이 전체적으로도 최선이길 바라는 알고리즘.
	
#### 단점
	- 단, 매 선택이 그 순간에 대해서는 최적이지만 그걸 종합적으로 봤을 땐 최적이 아닐 수 있음.
	- → 100% 최적해를 보장해주지 않음.
	- 예) 마시멜로 실험: 기다렸다가 2개를 먹는 실험, 탐욕 알고리즘 사용시에는 당장 먹어야 하므로 한 개만 먹을 수 있음. 즉 이 경우에는 최적해가 아님.
	
#### 사용 유형
	- 탐욕 선택 속성(greedy choice property), 최적 부분 구조(optimal substructure) 특성을 가지는 문제에 강점.
	- 한번의 선택이 다음 선택에는 전혀 무관한 값이어야 하며 매 순간의 최적해가 문제에 대한 최적해여야 한다는 의미.
	
###### 사용 예시
	- 최적 부분 구조
		- 예) 최단 경로를 찾는 문제
			- 서울에서 부산까지 가는 최단 경로 구하기
			- = 서울에서 대구까지 가는 최단 경로(200km) + 대구에서 부산까지 가는 최단 경로(80km) = 280km
			- = 각각의 부분 문제인 1)서울에서 대구까지 가는 최단 경로 문제 + 2)대구에서 부산까지 가는 최단 경로 문제의 해결 방법의 '합'
			
	- 활동 선택 문제(Activity selection problem)
		- 활동 중에서 종료 시간(finish time)이 가장 적고 시작 시간이 이전에 선택한 활동의 ​​종료 시간보다 크거(greater)나 같은(equal) 다음 활동을 항상 선택해야 함.
		- → 욕심쟁이는 매순간 활동이 빨리 끝날 것부터 선택해야 나머지 활동들을 선택할 확률이 높아지기 때문
		- 과정
			1. 각 활동들을 완료시간 기준으로 오름차순으로 정렬. 오름차순으로 정렬하는것은 활동이 가장 빨리 끝나는것부터 선택하려 하기 때문.
			2. 정렬된 활동들중 첫 번째 활동을 선택.
			3. 정렬된 활동들중 나머지 활동에 대해 이 활동의 ​​시작 시간이 이전에 선택한 활동의 ​​종료 시간보다 크거나 같으면이 활동을 선택함.
			
	- 거스름돈 문제
	- 최소 신장 트리(Minimum spanning tree)
	- 다익스트라 알고리즘
	- AI에 있어서 결정 트리 학습법(Decision Tree Learning)
	
###### 실패 유형 예시
	- 외판원 순회 문제 (TSP, Traveling Salesperson Problem)
	- 배낭 문제 (Knapsack Problem)

#### 근사 알고리즘
	- 최적해를 보장해주지 않으나 어느 정도 적합한 수준의 해답을 알려줌.
	- "되는가" 또는 "적당히 괜찮은 방법"을 찾을 때에는 사용 가능.
	- 계산속도가 정확한 알고리즘에 비해서 빠른 경우가 많기 때문에 실용적으로 사용이 가능.
	- 해답을 찾아가는 과정에 있어서 그리디로 구한 값을 비교값으로 설정할 수가 있음.
	
#### 출처
    - https://www.zerocho.com/category/Algorithm/post/584ba5c9580277001862f188
    - https://namu.wiki/w/%EA%B7%B8%EB%A6%AC%EB%94%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
    - https://jackpot53.tistory.com/102
		
