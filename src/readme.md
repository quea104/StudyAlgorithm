# 알고리즘 이론

## 그래프를 탐색하는 방법
- 그래프 Graph
	- 정점(node)과 그 정점을 연결하는 간선(edge)으로 이루어진 자료구조.
	- 그래프 탐색 = 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것.
	
- DFS
	- Depth-First Search; 깊이 우선 탐색.
	- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 최대한 깊이 내려간(=해당 분기(branch)를 완벽하게 탐색) 뒤 더이상 깊이 갈 곳이 없을 경우 옆(다음 분기)으로 이동.
	- 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색.
	- 스택 또는 재귀함수로 구현.
	- 구현 방식이 BFS 보다 간단.
	- 검색 속도가 BFS 보다 느림.
	- 문제 유형
		- 그래프의 모든 정점을 방문하기.
		- 경로의 특징을 저장하기.
		- 검색 대상 그래프의 규모가 큰 경우.
	- 의사코드	
		```
		dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점
		    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.
		    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)
		        if (visited[x] = NO) then dfs(V, E, x);
		}
		```

		
- BFS
	- Breadth-First Search; 너비 우선 탐색.
	- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 최대한 넓게 이동(=인접한 노드를 먼저 탐색)한 다음, 더 이상 갈 수 없을 때 아래로 이동.
	- 현재 정점에서 연결된 가까운 점들부터 탐색.
	- 큐로 구현.
	- 문제 유형
		- 그래프의 모든 정점을 방문하기.
		- 두 노드 사이의 최단 경로를 찾기.
		- 검색 대상 그래프의 규모가 크지 않고 검색 시작 지점으로부터 원하는 대상이 멀지 않은 경우.
	
- 시간복잡도
	- N: 노드, E: 간선
	- 인접 리스트로 구현 시: O(N+E) <- 효율적
	- 인접 행렬로 구현 시: O(N^2)
	
- 문제
	- TestBackJoon.D220825T1260DFSAndBFS class	


## 출처 
https://devuna.tistory.com/32